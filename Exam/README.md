# Контролно по СДП - практикум

24 декември 2015 г.

# Задача 1. 
(25 т.) Да се напише шаблонен клас ```StackQueue``` (може и друго, по-удобно за вас име), който реализира представяне на опашка чрез два стека. За целта да се използва готовият клас ```Stack``` от GitHub или класът ```stack``` от STL.
Принципът на опашката, представена чрез два стека, е следният:
-	в единият стек се добавят елементи;
-	от другия се изваждат;
-	ако искаме да извадим елемент от опашката или да достъпим върха, а стекът за вадене е празен, прехвърляме последователно в него всички елементи от другия стек.<br>
Класът ```StackQueue``` трябва да има следните методи: ```isEmpty()```, ```push()```, ```pop()```, ```getFront()``` и ```size()```. Също така, да се предефинира ```оператор <<``` за извеждане на опашката.

# Задача 2. 
(15 т.) Да се създаде едносвързан списък, чиито елементи са обекти на класа ```StackQueue<int>``` от задача 1. Като се използва готовият клас ```LListIter``` от GitHub и в класа StackQueue се добави ```оператор <```, който сравнява опашките в списъка по брой елементи в тях, да се сортира списъкът чрез неговия метод ```sort()```.<br>
```Забележка:``` Ако не сте успели да се справите със задача 1, може вместо ```StackQueue``` да ползвате готовия клас ```Queue``` от GitHub (или ```queue``` от STL), т.е. обикновената опашка.

# Бонус: Задача 3. 
(20 т.) Да се обходи списъкът от задача 2 чрез итератора, като от всяка опашка в него се вземе върхът и се запише във вектор. Т. к. итераторът на списъка е вътрешен клас, не можем да създадем обект от него извън класа ```LListIter```, но можем да получим итератор към елемента на позиция ```i``` по следния начин: ```l.begin() + i;``` (ако ```l``` е списъкът).

Решенията да се изпращат на ```upassistant2014@gmail.com```.
